" FUNCTIONS 
	" Only works in vimwiki filetypes
	" Input: empty- It will ask you what type of file you want to search
	" 		 String- "1", "2", or specify files in which you want to search
	function! s:GlobalSearch(type) abort 
		try
			"echomsg string(a:type)  " Debugging purposes
			if a:type == "0" 
				echo "Search Filetypes:\n\t1.Any\n\t2.Cpp\n\t3.Wiki" 
				let l:file = nr2char(getchar())
			else
				let l:file = a:type
			endif
			if !executable('ag') " use ag if possible 
				if l:file == 1
					let l:file = "**/*"
				elseif l:file == 2
					let l:file = "**/*.cpp **/*.h **/*.c **/*.hpp **/*.cc"
				elseif l:file == 3
					let l:file = "**/*.wiki"
				endif
				execute "vimgrep /" . input("Search in \"" . getcwd() . "\" for:") . "/ " . l:file
			else
				if l:file == 1
					let l:file = ""
				elseif l:file == 2
					let l:file = "--cpp"
				endif " relays on set grepprg=ag 
				execute "grep " . l:file . " " . input("Search in \"" . getcwd() . "\" for:")
			endif
			copen 20
		catch
			echohl ErrorMsg
			redraw " prevents the msg from misteriously dissapearing 
			echomsg "GlobalSearch(): " . matchstr(v:exception, ':\zs.*')
			echohl None
		endtry
	endfunction

	" Commits current buffer
	function! s:GitCommit() abort
		if <SID>CheckFileOrDir(1, ".git") > 0
			silent !git add .
			execute "silent !git commit -m \"" . input("Commit comment:") . "\""
			!git push origin master 
		else
			echo "No .git directory was found"
		endif
	endfunction

	" Should be performed on root .svn folder
	function! s:SvnCommit() abort
		execute "!svn commit -m \"" . input("Commit comment:") . "\" ."
	endfunction

	" Special comment function {{{
	function! s:FindIf() abort
		while 1
			" jump to matching {
			normal %
			" check to see if there is another else
			if match(getline(line(".")-1, line(".")), "else") > -1
				" search curr and previous 2 lines for }
				if match(getline(line(".")-2, line(".")), "}") > -1
					" jump to it
					execute "normal ?}\<CR>"
					" if there is no } could be no braces else if
				else
					" go up to lines and see what happens
					normal kk
				endif
			else
				" if original if was found copy it to @7 and jump back to origin
				execute "normal k^\"7y$`m"
				break
			endif
		endwhile
	endfunction

	function! s:TruncComment(comment) abort
		" brute trunc at 46
		let l:strip = a:comment
		if strchars(l:strip) > 46
			let l:strip = strpart(l:strip,0,46)
			let l:strip .= "..."
		endif
		" if theres a comment get rid of it
		let l:com = match(l:strip, "/")
		if l:com > -1
			let l:strip = strpart(l:strip,0,l:com-1)
		endif
		return l:strip
	endfunction

	" Gotchas: Start from the bottom up commenting
	function! s:EndOfIfComment() abort
		" TDOD: Eliminate comments on lines very important
		" is there a } in this line?
		"let g:testa = 0  " Debugging variable
		let l:ref_col = match(getline("."), "}")
		if  l:ref_col > -1 " if it exists
			" Determine what kind of statement is this i.e: for, while, if, else if
			" jump to matchin {, mark it with m, copy previous line to @8, and jump back down to original }
			"execute "normal mm" . l:ref_col . "|%k^\"8y$j%"
			execute "normal mm" . l:ref_col . "|%"
			let l:upper_line = line(".")
			execute "normal k^\"8y$j%"
			" if original closing brace it is and else if || else
			if match(getline(line(".")-1, line(".")), "else") > -1
				let g:testa = 1
				" if { already contains closing if put it
				" TODO:fix this to make search for else not only in @8 line
				if match(getline(l:upper_line-1,l:upper_line), "else") > -1
					" search upwards until you find initial if and copy it to @7
					call <SID>FindIf()
					" truncate comment line in case too long
					let @7 = <SID>TruncComment(@7)
					" append // "initial if..." : "
					let l:end = "  // \""
					execute "normal a" . l:end . @7 . "\" : \"\<Esc>"
				else
					let l:end = "  // \""
					execute "normal a" . l:end . "\<Esc>"
				endif
				" search openning brace for else
			elseif match(getline(l:upper_line-1,l:upper_line), "else") > -1
				let g:testa = 2
				" search upwards until you find initial if and copy it to @7
				call <SID>FindIf()
				" truncate comment line in case too long
				let @7 = <SID>TruncComment(@7)
				" append // "initial if..." : "
				let l:end = "  // End of \""
				execute "normal a" . l:end . @7 . "\" : \"\<Esc>"
				" if not very easy
			else 
				" Append // End of "..."
				let l:end = "  // End of \""
				execute "normal a" . l:end . "\<Esc>"
			endif
			" truncate comment line in case too long
			let @8 = <SID>TruncComment(@8)
			execute "normal a" . @8 . "\""
		else
			echo "EndOfIfComment(): Closing brace } needs to be present at the line"
		endif
	endfunction
	" End of Special Comment function }}}

	function! s:CheckDirwPrompt(name) abort
		if !has('file_in_path')  " sanity check 
			echo "CheckFileOrDir(): This vim install has no support for +find_in_path"
			return -10
		endif
		if a:type == 0  " use 0 for file, 1 for dir
			let l:func = findfile(a:name,",,")  " see :h cd for ,, 
		else
			let l:func = finddir(a:name,",,") 
		endif
		if !empty(l:func)
			return 1
		else
			execute "echo \"Folder " . escape(a:name, '\') . "does not exists.\n\""
			execute "echo \"Do you want to create it (y)es or (n)o\""
			let l:decision = nr2char(getchar())
			if l:decision == "y"
				if exists("*mkdir") 
					if has('win32') " on win prepare name by escaping '\' 
						let l:esc_name = escape(a:name, '\')
						execute "call mkdir(\"". l:esc_name . "\", \"p\")"
					else  " have to test check works fine on linux 
						execute "call mkdir(\"". a:name . "\", \"p\")"
					endif
					return 1
				else
					return -1
				endif
			endif
			return -1
		endif
	endfunction

	" This function silently attemps to create the directory its checking if it
	" exists in case it doesnt find it.
	" Compatible with both Linux and Windows
	function! <SID>CheckDirwoPrompt(name) abort
		if !has('file_in_path')  " sanity check 
			echo "CheckFileOrDir(): This vim install has no support for +find_in_path"
			return -10
		else
			if !empty(finddir(a:name,",,"))
				return 1
			else
				if exists("*mkdir") 
					if has('win32') " on win prepare name by escaping '\' 
						execute "call mkdir(\"". escape(a:name, '\') . "\", \"p\")"
					else  " have to test check works fine on linux 
						execute "call mkdir(\"". a:name . "\", \"p\")"
					endif
					return 1
				else
					echomsg string("No +mkdir support. Can't create dir")
					return -1
				endif
			endif
		endif
	endfunction

	function! s:YankFrom() abort
		execute "normal :" . input("Yank From Line:") . "y\<CR>"
	endfunction

	function! s:DeleteLine() abort
		execute "normal :" . input("Delete Line:") . "d\<CR>``"
	endfunction

	" TODO: substitute this for a custom neosnippet see :h neosnippet
	function! s:ListsNavigation(cmd) abort
		try
			let l:list = 0
			if !empty(getloclist(0)) " if location list is not empty
				let l:list = 1
				execute "silent l" . a:cmd
			elseif !empty(getqflist()) " if quickfix list is not empty
				execute "silent c" . a:cmd
			else
				echohl ErrorMsg
				redraw " always use it to prevent msg from dissapearing
				echomsg "ListsNavigation(): Lists quickfix and location are empty"
				echohl None
			endif
		catch /:E553:/ " catch no more items error 
			if l:list == 1
				silent .ll
			else
				silent .cc
			endif
		endtry
	endfunction

	function! s:SetDiff() abort
		nnoremap <C-Down> ]c
		nnoremap <C-Up> [c
		nnoremap <C-Left> :diffget<CR>
		nnoremap <C-Right> :diffput<CR>
		windo diffthis
	endfunction

	function! s:UnsetDiff() abort
		nunmap <C-Down>
		nunmap <C-Up>
		nunmap <C-Left>
		nunmap <C-Right>
		diffoff!
	endfunction

	function! s:CheckVimPlug() abort
		if empty(glob(s:vimfile_path . 'autoload/plug.vim'))
			if executable('curl')
				echomsg "Master I am going to install all plugings for you"
				execute "silent !curl -fLo " s:vimfile_path . "autoload/plug.vim --create-dirs"
					\" https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim"
				autocmd VimEnter * PlugInstall | source $MYVIMRC
			else
				echomsg "Master I cant install plugins for you because you"
							\" do not have curl. Please fix this"
			endif
		endif
	endfunction

	function! s:NormalizeWindowSize() abort
    execute "normal \<c-w>="
  endfunction

  function! Hex2Dec() abort
    execute "normal :echo str2nr('\<c-r>\<c-w>', 16)\<CR>" 
  endfunction

  " 8FFFF
  function! Dec2Hex() abort
    let l:sValue = expand("<cword>")
    echo l:sValue
    execute "normal :echo printf('%04X', '". l:sValue . "') str2nr('". l:sValue . "', 16) str2nr('". l:sValue . "', 2)\<CR>" 
    " execute "normal :echo str2nr('". l:sValue . "', 16)\<CR>" 
    " execute "normal :echo str2nr('". l:sValue . "', 2)\<CR>" 
  endfunction
  " F0
  " 240

  " Performance warning on this function. If necesary disable au and just make
  " function calls
  " Note: Keep in mind vim modelines for vim type of files
  function! s:SetupEnvironment()
    let l:path = expand('%:p')
    " use this as an example. just substitute NeoOneWINGS with your project
    " specific folder name
    if match(l:path,'NeoOneWINGS') > 0
      " set a g:local_vimrc_name in you local vimrc to avoid local vimrc
      " reloadings
      if !exists('g:local_vimrc_wings') 
        let g:local_vimrc_wings = 1
        if exists('g:local_vimrc_personal') 
          unlet g:local_vimrc_personal
        endif
        echomsg "Loading settings for Wings..."
        " This allows you to build using the command :make *.sln
        set makeprg=msbuild\ /nologo\ /v:q\ /property:GenerateFullPaths=true
        nnoremap <Leader>ma :make TsCommServer.sln<CR>
        " Disable syntastic
        SyntasticToggleMode
        " tab settings
        set tabstop=4     " a tab is four spaces
        set softtabstop=4
        set shiftwidth=4  " number of spaces to use for autoindenting
        set textwidth=120
      endif
    elseif match(l:path,'sep_calc') > 0 || match(l:path,'snippets') > 0 || match(l:path,'wiki') > 0
      if !exists('g:local_vimrc_personal') && exists('g:local_vimrc_wings')
        let g:local_vimrc_personal = 1
        unlet g:local_vimrc_wings
        echomsg "Loading settings for sep, snippets, and wikis..."
        " tab settings
        set tabstop=2
        set softtabstop=2
        set shiftwidth=2
        set textwidth=80
      endif
    endif
  endfunction

  function! s:FixPreviousWord() abort
    normal mm[s1z=`m
  endfunction

  function! s:SaveSession(...) abort
    " if session name is not provided as function argument ask for it
    if a:0 < 1
      execute "wall"
      execute "cd ". s:personal_path ."sessions/"
      let l:sSessionName = input("Enter 
            \save session name:", "", "file")
    else
      " Need to keep this option short and sweet
      let l:sSessionName = a:1
    endif
    execute "normal :mksession! " . s:personal_path . "sessions/". l:sSessionName  . "\<CR>"
    execute "cd -"
  endfunction

  nnoremap <Leader>sL :call <SID>LoadSession()<CR>
  function! s:LoadSession(...) abort
    " save all work
    execute "cd ". s:personal_path ."sessions/"
    " Logic path when not called at startup
    if a:0 < 1
      execute "wall"
      echo "Save Current Session before deleting all buffers: (y)es (any)no" 
      let l:iResponse = getchar()
      if l:iResponse == 121 " y
        call <SID>SaveSession()
      endif
      let l:sSessionName = input("Enter 
            \load session name:", "", "file")
    else
      let l:sSessionName = a:1
      echo "Reload Last Session: (y)es (d)ifferent session or (any)nothing"
      let l:iResponse = getchar()
      if l:iResponse == 100 " different session
        let l:sSessionName = input("Enter 
              \load session name:", "", "file")
      elseif l:iResponse == 121 " reload last session
        " continue to end of if
      else 
        " execute "normal :%bdelete\<CR>" " do not delete old buffers
        return
      endif
    endif
    execute "normal :%bdelete\<CR>"
    silent execute "normal :so " . s:personal_path . "sessions/". l:sSessionName . "\<CR>"
    execute "cd -"
  endfunction

  function! s:TodoCreate() abort
    execute "normal Blli\<Space>[ ]\<Space>\<Esc>"
  endfunction

  function! s:TodoMark() abort
    execute "normal Bf[lrX\<Esc>"
  endfunction

  function! s:TodoClearMark() abort
    execute "normal Bf[lr\<Space>\<Esc>"
  endfunction

  function! s:OpenWiki(sWikiName) abort
    execute "e " . s:personal_path . "wiki/" . a:sWikiName
  endfunction

  function! s:CommentDelete() abort
    execute "normal Bf/D"
  endfunction

  function! s:CommentIndent() abort
    execute "normal Bf/i\<Tab>\<Tab>\<Esc>"
  endfunction

  function! s:CommentReduceIndent() abort
    execute "normal Bf/hxhx"
  endfunction

  function! s:CommentLine() abort
    if exists("*NERDComment")
      execute "normal mm:" . input("Comment Line:") . "\<CR>"
      execute "normal :call NERDComment(\"n\", \"Toggle\")\<CR>`m"
    else
      echo "Please install NERDCommenter"
    endif
  endfunction

  " vim:tw=78:ts=2:sts=2:sw=2:
